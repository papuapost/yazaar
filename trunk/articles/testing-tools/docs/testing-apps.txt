In this article, you will learn:

* When, where, and how to test Ajax components;
* How to create automatic tests with popular, free, open-source tools;
* How to use testing tools with IDEs and Continuous Integration systems.

----

Source: 1400 words
Target: 2500 to 4000 words 

----


Testing Ajax Web Applications from Square One by Ted Husted

Not long ago, testing Ajax components meant play-testing a page by hand. Today, there are a growing number of tools we can use to simplify and automate Ajax testing.

In this article, we spell out when to test, what to test, and how to test Ajax components. We demonstrate creating automatic tests with YUI Test and OpenQA Selenium, continuous integration systems, like CruiseControl or Hudson.

We'll start by introducing Ajax as a technology. Building on that foundation, we then introduce an application we can test with our suite of open source testing tools.  


What is Ajax?

The term Ajax was coined in 2005 as an acronym for "Asynchronous JavaScript And XML". The term describes a technique where a script running inside of a browser makes requests to a server and updates the content dynamically, without the usual full-page refresh. Though the acronym is recent, the technique itself dates back to 1998. 

The goal is to let web pages behave less like flat documents and more like dynamic GUI applications. In fact, the popular form of the technique was born out of an attempt to make the Microsoft Exchange Web Client look exactly like Outlook <http://msexchangeteam.com/archive/2005/06/21/406646.aspx>. Today, many web-based applications have a rich, GUI-like, look and feel.


How does Ajax work?

Ajax works its magic using a (still) non-standard, but ubiquitous, asynchronous  JavaScript feature known as the XMLHttpRequest (or XHR). We can trigger an XHR using any JavaScript event: pressing a button, changing a list selection, tabbing from field to field. The XHR differs from an ordinary HttpRequest in that it works asynchronously. The script fires off the call and goes merrily on its way, without pausing for a response. Instead of waiting, the script registers a "callback" method that can be invoked when the response returns. In the meantime, the script can continue, or even end, and the application doesn't seem to lockup or stall waiting for the server respond. 

"Callout:" 
The XHR differs from an ordinary HttpRequest in that it works asynchronously ... and the application doesn't seem to lockup or stall waiting for the server respond."

When the response does return, the script engine invokes the callback method. The method can then use the content returned in the response to update the page dynamically. We may call it a XMLHttpRequest, but the content it returns can be anything: plain text, a HTML fragment, XML; whatever we need. The Ajax lifecycle is illustrated in the figure "Ajax in Action". 

"Figure: Ajax in Action" 
[TBD: ajax-in-action.png]

While this article isn't intended as an Ajax tutorial, a simple Hello World illustration will make it easier to understand testing JavaScript applications. The HTML code in the example "Simple Javascript Application" presents a message when the button is clicked and pops up an Alert dialog. 

"Example: Simple JavaScript Application" 
[hello-world.html]

To simplify the code, the script uses the popular Yahoo! User Interface (YUI) library. Given an Internet connection, you can copy the example to a HTML file and open it with a browser. The figure "Hello World Storyboard" shows the example in action. 

"Figure: Hello World Storyboard" 
[TBD: hello-world.png]
[TBD: hello-world-alert.png]

While we could use Hello World to demonstrate testing a JavaScript application, it's not a true Ajax application, since we do not use a XHR to interact with the server. To introduce a XHR, we can add a server-side file to provide the "Hello World" text, and a callback function to receive the response and present the text. The HTML code in the example "Simple Ajax application" presents a message when the callback succeeds.

"Example: Simple Ajax Application" 
[ajax-works.html]

In the update example, we read the contents of the server-side "ajax-works-result.txt", and present it on the web page. Unlike the JavaScript example, the Ajax example requires the use of a web server to read the file for us. (For this example, any web server would do.) The figure "Ajax Works Storyboard" shows what happens when the example succeeds, and what happens when the file is missing, and Ajax Works fails. 

"Figure: Ajax Works Storyboard" 
[TBD: ajax-works.png]
[TBD: ajax-works-success.png]
[TBD: ajax-works-failure.png]


How do we test it?

In the beginning, all JavaScript and Ajax testing came in the form of Alerts, like those we used with Ajax Works. Today, the scripting landscape is almost crowded with testing tools. In January 2009, the website opensourcetesting.org includes 16 matches for JavaScript tools and 7 for Ajax, as shown by the figure "Open Source Testing Tools". 

"Figure: Open Source Testing Tools" 
[TBD: opensourcetesting.png]

In this article, we'll look at two tools for testing Ajax at different levels, and a third tool for continuous integration. 

* YUI Test (http://developer.yahoo.com/yui/) is an unit testing framework for adding code-level tests to browser-based JavaScript solutions. If you're familiar with other unit testing frameworks, YUI Test derives characteristics from NUnit (http://www.nunit.org/) and JUnit (http://www.junit.org/).

* Open QA Selenium (http://seleniumhq.org/) is a functional testing framework for adding UI-level tests to browser-based JavaScript solutions. If you're familiar with other functional testing frameworks, Selenium is similar in design to Canoo Web Test (http://webtest.canoo.com/) and Mercury. 

* Hudson (https://hudson.dev.java.net/) is a continuous integration framework for compiling application and running tests on an automatic or regular basis. CI frameworks like Hudson include Cruise Control (http://cruisecontrol.sourceforge.net/) and Bamboo.

Using this set of tools, we can test an Ajax application like we would test any other solution. We can start with unit tests against the internal code, and then add functional tests against the external user interface. With internal and external tests in place, we can use a continuous integration system to run the tests automatically. 


How do we test Ajax with YUI Test?

When we test conventional applications with frameworks like JUnit and NUnit, our goal is to test the code at the "unit of work" level. In practice, unit testing means using a second program (or test case) to exercise the public methods within a class. The example "Hello NUnit" shows the source and output for a simple NUnit test setup. 

"Example: Hello NUnit" 
[TestNUnit.cs]
[TBD: TestNUnit.png]

Yahoo's YUI Test framework follows the same paradigm as JUnit or NUnit. To unit test our code, we create a test case, in the form of a HTML page, to exercise the public methods with a script. YUI Test even has its own version of a test runner that pops up over the page and displays the outcome of the test methods. The example "Hello YUI" shows the source and output for a simple YUI test setup. 

"Example: Hello YUI Test" 
[test-yui-setup.html]
[TBD: test-yui-setup.png]

In our first Hello World example, we embedded some test code, in the form of an alert, into the HTML code. Let's try the same sort of thing with YUI. 

A key feature of YUI Test is that it can select user controls so that tests can run unattended. If we also move the page's script into a separate file, we can call the same script from the production page and the unit test. The example "Test Hello World" shows a YUI Test that clicks the button to present the message, and itemizes the result in the test logger. 

"Example: Test Hello World" 
[hello-world-2.html]
[TBD: hello-world-2.png]
[hello-world-2.js]
[test-hello-world.html]
[TBD: test-hello-world.png]

That was easy! Let's try it with the Ajax example. (A few minutes later.) Hmmm, that's strange. As shown in the figure "Ajax False Positive", the screen renders correctly, but the YUI Test logger says it failed ...

"Figure: Ajax False Positive" 
[TBD: ajax-false-positive.png]

The false positive is a result of the asynchronous nature of Ajax. The browser doesn't wait for the Ajax XHR response, and the test script continues to run. Microseconds later, the response returns, but it's too late. The test has already reported failure!  

To test asynchronous code, YUI Test provides a wait() method that can be used in two different ways. Without a parameter, the wait() method exits the script until a resume method is called (usually by a callback handler). The resume() method accepts a single parameter, which is a function to run when the script resumes. Alternatively, a function can be passed to wait() with a timeout value (in miliseconds). When the timeout expires, YUI runs the function. 



 

How do we test Ajax with Selenium? 




How do we run our tests automatically with Hudson?



Is that all there is?

Using tools like YUI Test, Selenium, and Hudson, we can test Ajax applications as easily as conventional web applications. Aside from the products discussed here, there are alternatives in each category, like JS Unit, Webtest Canoo, and Cruise Control. The sidebar "Testing Tool Review" outlines some pros and cons of each product. 

"Sidebar: Testing Tool Review" 
[TBD]


The important thing is to try one or more of these tools with your next project, and follow Kent Beck's sage advice: "Test until fear turns to boredom!"

####
