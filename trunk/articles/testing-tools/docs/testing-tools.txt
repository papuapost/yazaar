It would be even simpler to collect input and present the output without talking to the server. But, without the server, we wouldn't be testing a working Ajax application -- only a lonely JavaScript application. Server-side interaction puts the A in Ajax.

http://www.alexhopmann.com/story-of-xmlhttp/



----

Not long ago, testing web applications with Ajax components meant play-testing a page by hand. Today, there are a growing number of tools we can use to simplify and automate Ajax testing.

In this session we will cover when to test, what to test and how to test web applications with Ajax components. You learn how to create automatic tests with tools like OpenQA Selenium, and how to use Ajax testing tools with continuous integration systems, like CruiseControl or Hudson.

In this session, you will learn:

 * How Ajax works, and why it complicates testing;
 * When, where, and how to test Ajax components;
 * How to use Ajax testing tools with continuous integration systems.

 ----

Testing Ajax Web Applications from Square One by Ted Husted

Not long ago, testing Ajax components meant play-testing a page by hand. Today, there are a growing number of tools we can use to simplify and automate Ajax testing.

In this article, we spell out when to test, what to test, and how to test Ajax components. We demonstrate creating automatic tests with YUI Test and OpenQA Selenium, as well using Ajax testing tools with IDEs and continuous integration systems, like CruiseControl or Hudson.

In this article, you will learn:

* When, where, and how to test Ajax components;
* How to create automatic tests with popular, free, open-source tools;
* How to use testing tools with IDEs and Continuous Integration systems.


What is Ajax?

The term Ajax was coined in 2005 as an acronym for "Asynchronous JavaScript And XML". The term describes a technique where a script running inside of a browser makes requests to a server and updates the content dynamically, without the usual full-page refresh. Though the acronym is recent, the technique itself dates back to 1998. 

The goal is to let web pages behave less like flat documents and more like dynamic GUI applications. In fact, the popular form of the technique was born out of an attempt to make the Microsoft Exchange Web Client look exactly like Outlook <http://msexchangeteam.com/archive/2005/06/21/406646.aspx>. Today, many web-based applications have a rich, GUI-like, look and feel.


How does Ajax work?

Ajax works its magic using a non-standard, but ubiquitous, asyncronous JavaScript feature known as the XMLHttpRequest (or XHR). We can trigger an XHR using any JavaScript event: pressing a button, changing a list selection, tabbing from field to field. The XHR differs from an ordinary HttpRequest in that it works asynchronously. The script fires off the call, and the proceeds on its way, without waiting for a response. Instead of waiting, the script registers a "callback" method that can be invoked when the response returns. In the meantime, the script can continue, or even end, and the application doesn't seem to lockup or stall. 

When the response does return, the script engine invokes the callback method. The method can then use the content returned in the response to update the page dynamically. We may call it a XMLHttpRequest, but the content it returns can be anything: plain text, a HTML fragment, XML; whatever we need. 


What's the simplest Ajax application that we could possibly test?
 
Automated testing is popular in Agile development disciplines, like Extreme Programming. In XP, we usually try to start with the simplest implementation that can possibly work, prove that it works with automatic unit tests, and then refactor the implementation to meet all of its functional and nonfunctional requirements. 

To kick-off our review of testing tools, let's start with the simplest Ajax application that we could possibly test. As a design pattern, Ajax lets us update the state of the application and conform the presentation, without resorting to a full browser page refresh. Accordingly, our simple Ajax application would need to:  

 * collect input, 
 * interact with the server, and 
 * present output,  

all without reloading the page. 

For the application to both simple and realistic, there should also be the potential for error when interacting with server. Depending on the input, we should be able to present an error message as output. 

One of the most common workflows in a business applications is authenticating users with a login/logout routine. A typical routine is described by "Figure 1: Sign In and Out Use Case." 

----

"Figure 1: Sign In and Out Use Case" 

Main Success Scenario (MSS)

  1 Unauthenticated user access the application 
  2 System presents username and password text input controls, with another control labeled "Sign In".
  3 User inputs credentials and selects the "Sign In" control.
  4 System validates input against business rules.
  5 System authenticates credentials against application state.
  6 System presents the message "Welcome ${username}" and a "Sign Out" control.
  7 User continues to interact with the system without being prompted for credentials.
  8 User selects Sign Out control. 
  9 System unathenticates user.

Extension to MSS

  4a Username validation fails
  .1 System determines username input is empty or not a valid format for an email address.
  .2 System presents validation message in the form "${username}is required and must be a valid email format."
  .3 Return at MSS 2
   
  4b Password validation fails
  .1 System determines username input is empty not a valid format for a password.
  .2 System presents validation message in the form "${password} is required and must be a valid password format.".
  .3 Return at MSS 2
  
  5a Authentification fails
  .1 System determines that the username does not exist in application state.
  .2 System presents validation message in the form "The username and password combination must match our records.".
  .3 Return at MSS 2.
  
  7a Autentification times-out
  .1 User discontinues interaction with system.
  .2 System notes inactivity and unathenticates user.
  .3 Return at MSS 1.

----
  
Of course, Steps 8 and 9 in Figure 1 could also be part of a separate "Sign Out" use case, but for our purposes, it's more effective to keep everything as a single workflow. 
 
Where do we begin?

With a use case in hand (see Figure 1), we can whip up a quick UI sketch as shown in "Figure 2: 
Sign In Wireframes".

----

"Figure 2: Sign In Wireframes" 

 ...  Username:[        ] Password:[        ]  [Sign In]
--

 ...  Username:[husted@apache.org    ] Password:[********   ]  [Sign In]

 ...  | Alert |
      | Username is required and must be a valid email format. |
	  | Password is required and must be a valid password format. |
      | [OK] | 
--
 .... Welcome ${Username} [Sign Out]
 
----

The next step is to design a aystem interface for our application, and then we can work on the user interface. Since we're designing an Ajax application, our system interface includes a connection method and a callback method. The Ajax interface also includes any events we need to raise, to indicate system state. Example 1 "Authentification Interface" shows the method signatures and events that we can use. 


-----

System Use Cases 
 * Present "Sign In" controls
 * Read input 
 ** Validate input
 ** Submit input
 * Present "Sign Out" controls
 * Present alerts

System Methods 
 * signin_present(button) 
 * signin_submit(username, password)
 * signin_validate_username(username)
 * signin_validate_password(password)
 * validate_message(message)

----

method signatures 


authenticate_connect(username, password) 

authenticate_callback(e) 


events 

authenticate_success

authenticate_failure 



<html>
<head>
  <title>Simple Hello World Example</title>
  <script src="http://yui.yahooapis.com/2.5.2/build/yahoo-dom-event/yahoo-dom-event.js"></script>
  <script src="http://yui.yahooapis.com/2.5.2/build/element/element-beta-min.js"></script>
</head>
<body>
  <input id="hello-button" type="button" value="Say Hello World via AJAX" />
  <br /><br />
  <div id="hello-div"></div>
  <script>
	var elButton = new YAHOO.util.Element('hello-button');
	var elDiv = YAHOO.util.Dom.get("hello-div");
	var handleClick = function(e) {
		elDiv.innerHTML = this.get("value");
		alert(this.get('id') + " raised " + e.type);
		this.removeListener(handleClick); 
	};
	elButton.on('click', handleClick, elButton); 
  </script>
  </body>
</html>

----

<html>
<head>
  <title>Simple Hello World Example</title>
  <script src="http://yui.yahooapis.com/2.5.2/build/yahoo-dom-event/yahoo-dom-event.js"></script>
  <script src="http://yui.yahooapis.com/2.5.2/build/element/element-beta-min.js"></script>
  <script src="http://yui.yahooapis.com/2.2.2/build/yahoo/yahoo-min.js" type="text/javascript"></script> 
  <script src="http://yui.yahooapis.com/2.2.2/build/connection/connection-min.js" type="text/javascript"></script>
</head>
<body>
  <input id="hello-button" type="button" value="Say Hello World via AJAX" />
  <br /><br />
  <div id="hello-div"></div>
  <script>
	var elButton = new YAHOO.util.Element('hello-button');
	var elDiv = YAHOO.util.Dom.get("hello-div");
	var sUrl = "index-result.txt";
	
	var callback = {
     success: function(o) {
	    // elDiv.innerHTML = value;
        alert("AJAX Works"); //SUCCESS
        },
     failure: function(o) {
        alert("AJAX doesn't work"); //FAILURE
     }
	}
	
	var handleClick = function(e) {
		var transaction = YAHOO.util.Connect.asyncRequest('GET', sUrl, callback, null); 
		this.removeListener(handleClick);		
	};
	elButton.on('click', handleClick, elButton); 

	</script>
  </body>
</html>

----
+	var sUrl = "index-result.do";
+ 	var sUrl = "index-result.action";
----

One of the most popular Ajax widgets is an Autocomplete control, where the system predicts a word or phrase that we mean to enter before we enter it completely. Autocomplete controls are used to opine terms we have input before, stored in a local cache, or to suggest terms from a rapid search on a remote database. 

A well-known example of autocomplete is Google Search. Rather than waste time typing in an entire search term, Google Search executes a series of searches while we type, as shown in Figure 1: "Hello Wo! (2)". 

"Figure 1: Hello Wo!" 
[figure-1-hello-wo.gif]

Other examples of autocomplete abound. Email clients offer up contacts from our address books. Web forms eerily remember data we typed into other forms. Code editors eagerly offer attributes. 

Let's start by coding and testing the simplest case first, and then move on to a more interesting example that fully utilizes the Ajax model. The simplest case would be offering suggestions from a list in memory, such as list of US states. "Example 1: ListSearch.html" shows our first autocomplete application. 

"Example 1: ListSearch.html"

Our ListSearch example is based on the Yahoo! User Interface (YUI) Library, and we can write our first tests usng YUI Test from the same library. 

(Testing the local list.) 

(Moving the list to a server.)


